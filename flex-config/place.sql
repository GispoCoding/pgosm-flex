COMMENT ON TABLE osm.place_point IS 'OpenStreetMap named places and administrative boundaries. Generated by osm2pgsql Flex output using pgosm-flex/flex-config/place.lua';
COMMENT ON TABLE osm.place_line IS 'OpenStreetMap named places and administrative boundaries. Generated by osm2pgsql Flex output using pgosm-flex/flex-config/place.lua';
COMMENT ON TABLE osm.place_polygon IS 'See view: osm.vplace_polgyon for improved data.  OpenStreetMap named places and administrative boundaries.  Contains relations and the polygon parts making up the relations. Generated by osm2pgsql Flex output using pgosm-flex/flex-config/place.lua';


COMMENT ON COLUMN osm.place_point.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';
COMMENT ON COLUMN osm.place_line.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';
COMMENT ON COLUMN osm.place_polygon.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';


COMMENT ON COLUMN osm.place_point.osm_type IS 'Values from place if a place tag exists.  If no place tag, values boundary or admin_level indicate the source of the feature.';
COMMENT ON COLUMN osm.place_line.osm_type IS 'Values from place if a place tag exists.  If no place tag, values boundary or admin_level indicate the source of the feature.';
COMMENT ON COLUMN osm.place_polygon.osm_type IS 'Values from place if a place tag exists.  If no place tag, values boundary or admin_level indicate the source of the feature.';


ALTER TABLE osm.place_point
    ADD CONSTRAINT pk_osm_place_point_osm_id
    PRIMARY KEY (osm_id)
;
ALTER TABLE osm.place_line
    ADD CONSTRAINT pk_osm_place_line_osm_id
    PRIMARY KEY (osm_id)
;
ALTER TABLE osm.place_polygon
    ADD CONSTRAINT pk_osm_place_polygon_osm_id
    PRIMARY KEY (osm_id)
;


CREATE INDEX ix_osm_place_point_type ON osm.place_point (osm_type);
CREATE INDEX ix_osm_place_line_type ON osm.place_line (osm_type);
CREATE INDEX ix_osm_place_polygon_type ON osm.place_polygon (osm_type);


CREATE VIEW osm.places_in_relations AS
SELECT p_no_rel.osm_id
    FROM osm.place_polygon p_no_rel
    WHERE osm_id > 0
        AND EXISTS (SELECT * 
            FROM (SELECT i.osm_id AS relation_id, 
                        jsonb_array_elements_text(i.member_ids)::BIGINT AS member_id
                    FROM osm.place_polygon i
                    WHERE i.osm_id < 0
                    ) rel
            WHERE rel.member_id = p_no_rel.osm_id
            ) 
;

COMMENT ON VIEW osm.places_in_relations IS 'Lists all osm_id values included in a relation''s member_ids list.  Technically could contain duplicates, but not a concern with current expected use of this view.';
COMMENT ON COLUMN osm.places_in_relations.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';


CREATE MATERIALIZED VIEW osm.vplace_polygon AS
SELECT p.*
    FROM osm.place_polygon p
    WHERE NOT EXISTS (
        SELECT 1 
            FROM osm.places_in_relations pir 
            WHERE p.osm_id = pir.osm_id)
;

CREATE UNIQUE INDEX uix_osm_vplace_polygon_osm_id
    ON osm.vplace_polygon (osm_id);
CREATE INDEX gix_osm_vplace_polygon
    ON osm.vplace_polygon USING GIST (geom);



COMMENT ON MATERIALIZED VIEW osm.vplace_polygon IS 'Simplified polygon layer removing non-relation geometries when a relation contains it in the member_ids column.';
COMMENT ON COLUMN osm.vplace_polygon.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';



DROP TABLE IF EXISTS osm.place_polygon_nested;
CREATE TABLE osm.place_polygon_nested
(
    osm_id BIGINT NOT NULL PRIMARY KEY,
    name TEXT NOT NULL,
    osm_type TEXT NOT NULL,
    admin_level INT NOT NULL,
    nest_level BIGINT NULL,
    name_path TEXT[] NULL,
    osm_id_path BIGINT[] NULL,
    admin_level_path INT[] NULL,
    geom GEOMETRY NOT NULL, -- Can't enforce geom type b/c SRID is dynamic project wide. Can't set MULTIPOLYGON w/out SRID too
    CONSTRAINT fk_place_polygon_nested
        FOREIGN KEY (osm_id) REFERENCES osm.place_polygon (osm_id) 
);


CREATE INDEX ix_osm_place_polygon_nested_osm_id
    ON osm.place_polygon_nested (osm_id)
;
CREATE INDEX ix_osm_place_polygon_nested_name_path
    ON osm.place_polygon_nested USING GIN (name_path)
;
CREATE INDEX ix_osm_place_polygon_nested_osm_id_path
    ON osm.place_polygon_nested USING GIN (osm_id_path)
;

COMMENT ON TABLE osm.place_polygon_nested IS 'Provides hierarchy of administrative polygons.  Built on top of osm.vplace_polygon. Artifact of PgOSM-Flex (place.sql).';

COMMENT ON COLUMN osm.place_polygon_nested.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.';


COMMENT ON COLUMN osm.place_polygon_nested.admin_level IS 'Value from admin_level if it exists.  Defaults to 99 if not.';
COMMENT ON COLUMN osm.place_polygon_nested.nest_level IS 'How many polygons is the current polygon nested within.  1 indicates polygon with no containing polygon.';
COMMENT ON COLUMN osm.place_polygon_nested.name_path IS 'Array of names of the current polygon (last) and all containing polygons.';
COMMENT ON COLUMN osm.place_polygon_nested.osm_id_path IS 'Array of osm_id for the current polygon (last) and all containing polygons.';
COMMENT ON COLUMN osm.place_polygon_nested.admin_level_path IS 'Array of admin_level values for the current polygon (last) and all containing polygons.';


INSERT INTO osm.place_polygon_nested (osm_id, name, osm_type, admin_level, geom)
SELECT p.osm_id, p.name, p.osm_type,
        COALESCE(p.admin_level::INT, 99) AS admin_level,
        geom
    FROM osm.vplace_polygon p
    WHERE p.boundary = 'administrative'
        AND p.name IS NOT NULL
;






CREATE OR REPLACE PROCEDURE osm.build_nested_admin_polygons(
     batch_row_limit BIGINT = 100
 )
 LANGUAGE plpgsql
 AS $$
 DECLARE
     rows_to_update BIGINT;
 BEGIN

 SELECT  COUNT(*) INTO rows_to_update
     FROM osm.place_polygon_nested r
     WHERE nest_level IS NULL
 ;
 RAISE NOTICE 'Rows to update: %', rows_to_update;
 RAISE NOTICE 'Updating in batches of % rows', $1;

 FOR counter IN 1..rows_to_update by $1 LOOP

    DROP TABLE IF EXISTS place_batch;
    CREATE TEMP TABLE place_batch AS
    SELECT p.osm_id, t.nest_level, t.name_path, t.osm_id_path, t.admin_level_path
        FROM osm.vplace_polygon p
        INNER JOIN LATERAL (
            SELECT COUNT(i.osm_id) AS nest_level,
                    ARRAY_AGG(i.name ORDER BY i.admin_level ASC) AS name_path,
                    ARRAY_AGG(i.osm_id ORDER BY i.admin_level ASC) AS osm_id_path,
                    ARRAY_AGG(COALESCE(i.admin_level::INT, 99::INT) ORDER BY i.admin_level ASC) AS admin_level_path
                FROM osm.vplace_polygon i
                WHERE ST_Within(p.geom, i.geom)
                    AND i.boundary = p.boundary
                    AND i.name IS NOT NULL
               ) t ON True
        WHERE EXISTS (
                SELECT 1 FROM osm.place_polygon_nested miss
                    WHERE miss.nest_level IS NULL
                    AND p.osm_id = miss.osm_id
        )
    LIMIT $1
;

    UPDATE osm.place_polygon_nested n 
        SET nest_level = t.nest_level,
            name_path = t.name_path,
            osm_id_path = t.osm_id_path,
            admin_level_path = t.admin_level_path
        FROM place_batch t
        WHERE n.osm_id = t.osm_id
        ;
    COMMIT;
    END LOOP;

    DROP TABLE IF EXISTS place_batch;

END $$; 



COMMENT ON PROCEDURE osm.build_nested_admin_polygons IS 'Warning: Expensive procedure!  Use to populate the osm.place_polygon_nested table.  Not ran as part of SQL script automatically due to excessive run time on large regions.';

-- Commented out on purpose -- see comment above
--CALL osm.build_nested_admin_polygons();



CREATE MATERIALIZED VIEW osm.vplace_polygon_subdivide AS
SELECT osm_id, ST_Subdivide(geom) AS geom
    FROM osm.vplace_polygon
;
CREATE INDEX gix_osm_vplace_polygon_subdivide
    ON osm.vplace_polygon_subdivide USING GIST (geom)
;

COMMENT ON MATERIALIZED VIEW osm.vplace_polygon_subdivide IS 'Subdivided geometry from osm.vplace_polygon.  Multiple rows per osm_id, one for each subdivided geometry.';

COMMENT ON COLUMN osm.vplace_polygon_subdivide.osm_id IS 'OpenStreetMap ID. Unique along with geometry type.  Duplicated in this view!';

